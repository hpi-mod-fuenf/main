%7
\section{Paketdetails}
\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img/7-paketdetails}
\caption{Klassendiagramm zur detaillierten Beschreibung der strukturellen Gliederung}
\label{Paketdetails}
\end{figure}

%7.1 Paket Robot
\subsection{Paket \textit{Robot}}
	Im Folgenden beschreiben wir die wichtigen Klassen des Pakets \textit{Robot} 
	und ihre zugehörigen wichtigen Methoden, sowie ihre Interaktion untereinander. 


	%7.1.1 RobotController
	\subsubsection{Beschreibung der Klasse \textit{RobotController}}
%		\begin{figure}[H]
%		\centering
%		\includegraphics[width=0.6\textwidth]{../images/Iteration0_Entwurf_7-1-1_Klasse_RobotController}
%		\caption{\textcolor{blue}{Durch eigene Diagramme ersetzen}}
%		\label{BeschreibungKlasse1}
%		\end{figure}
		
		%#destination : Destination
		Die Klasse \textit{RobotController} ist die Hauptklasse des \textit{Robots}, 
		da sie den aktuellen Zustand des \textit{Robots} enthält.
		So hat diese Klasse die Möglichkeit, maximal einen \textit{Task} zu speichern. 
		Dieser \textit{Task} kann ein vom \textit{Server} zugeteiltes Ziel sein, 
		der dem \textit{Robot} zugehörige \textit{Charger}, oder gerade kein Ziel, 
		also \texttt{null} sein. 

			%7.1.1.1 #collectSensorData():void
			\paragraph{Beschreibung der Methode \texttt{readSensors}}
			Der Server kann einen \textit{Robot} dazu auffordern, ihm seine Soensordaten zu schicken. 
			Der \textit{Robot} fragt dann seine Hardwareschnittstelle mittels der Methode \texttt{readSensors} 
			nach seiner Position und seinem Akkustand an und gibt diese Informationen zusammen mit einer Information über seinen aktuellen Zustand (also seinem aktuellen \textit{Task}) zurück an den \textit{Server}. 
			Dazu wird natürlich zunächst eine \textit{Message} verfasst, welche dann über die im \texttt{Common}-Paket enthaltene Schnittstelle über den \textit{IWlanAdapter} mit der Methode \texttt{send} verschickt wird.
			
			\paragraph{Beschreibung der Methode \texttt{setTask}}
			Diese Methode wird aufgerufen, wenn der \textit{Robot} einen neuen Task erhält. Wenn der \textit{Robot} davor keinen \textit{Task} hatte, wird dieser einfach ausgeführt. Wenn der übergebene \textit{Task} \texttt{null} ist, nimmt der \textit{Robot} fahrt zur Ladestation auf. Wenn der \textit{Robot} gerade einen \textit{TaxiCustomer} an bord hat und in dieser Methode einen Krankenhaustransport als \textit{Task} erhält, wird der \textit{TaxiCustomer} abgeladen, und der Krankenhaustransport wird ausgeführt.
			
	\subsubsection{Beschreibung der Klasse \textit{VirtualServer}}
	Die Klasse \textit{VirtualServer} ist die Klasse, welche die Remote-Procedure-Calls von der Seite des \textit{Robots} implementiert. \textit{VirtualServer} implementiert unsere in 3. definierten Interfaces \textit{IRepair} und \textit{IArrivalNotification}. Alle Methoden in dieser Klasse verfassen natürlich eine \textit{Message} und nutzen dann die \textit{IWlanAdapter}-Schnittstelle, um diese an den \textit{Server} zu schicken.
	
			\paragraph{Beschreibung der Methode \texttt{informAboutArrival}}
			Diese Methode wird immer dann aufgerufen, wenn der \textit{Robot} die nächste \textit{Position} von seinem aktuellen \textit{Task} erreicht hat.  Da der \textit{Server} weiß, welcher \textit{Task} von welchem \textit{Robot} ausgeführt wird, muss \texttt{informAboutArrival} keine Parameter übergeben.
	
			\paragraph{Beschreibung der Methode \texttt{requestRepair}}
			Diese Methode wird dann von einen \textit{Robot} aufgerufen, wenn er nach einem Unfall kaputt ist. Der \textit{Robot} verfasst dafür eine \textit{Message} an den \textit{Server}, woraufhin auf dem \textit{Server} der \textit{Task}, den der kaputte \textit{Robot} gerade ausführen sollte, neu verteilt. In seiner Prioritätsstufe ist dieser \textit{Task} dann an erster Stelle, und wird nicht wieder hinten angestellt. Zusätzlich wird auf dem \textit{Server} dann die Methode \texttt{notifyRepairService} aufgerufen.		
			
	%7.1.2 DrivingSystem
	\subsubsection{Beschreibung der Klasse \textit{DrivingSystem}}
%		\begin{figure}[H]
%		\centering
%		\includegraphics[width=0.6\textwidth]{../images/Iteration0_Entwurf_7-1-2_Klasse_DrivingSystem}
%		\caption{\textcolor{blue}{Durch eigene Diagramme ersetzen}}
%		\label{BeschreibungKlasse1}
%		\end{figure}
		
		%#currentSpeed:float
		Diese Klasse beschreibt den aktuellen Zustand des Fahrsystems des \textit{Robots}. 
		Es sind Informationen über die aktuelle Geschwindigkeit enthalten und die Methode, 
		die gerade ausgeführt wird, gibt Auskunft über die aktuelle Beschäftigung des \textit{Robots}.

			%7.1.2.1 	#driveToDestination(destination: Destination, arrivalHandler: ArrivalHandler): void
			\paragraph{Beschreibung der Methode \texttt{driveToDestination}}
			\begin{figure}[H]
			\centering
			\includegraphics[width=1\textwidth]{img/1-Entwurf-7-1-methode_driveAroundObstacle}
			\caption{Aktivitätsdiagramm zur Methode \texttt{driveToDestination}}
			\label{AktivitaetDriveToDestination}
			\end{figure}

			Wenn diese Methode aufgerufen wird, macht der \textit{Robot} sich auf den Weg zur 
			übergebenen \textit{Destination}. Wenn der \textit{Robot} an dieser \textit{Destination} 
			angekommen ist, wird die \texttt{arrive}-Methode des übergebenen \textit{ArrivalHandlers} ausgeführt. Wenn es sich bei der \textit{Destination} nicht um einen \textit{Charger} handelte, wird darin insbesondere über die von uns definierte Schnittstelle \textit{IArrivalNotifivation} der \textit{Server} über die Ankunft benachrichtigt. 
			Wenn sich ein \textit{Obstacle} auf dem Weg befindet, wird die Methode \texttt{driveAroundObstacle} 
			aufgerufen, bis das \textit{Obstacle} umfahren wurde.
			
			Abbildung \ref{AktivitaetDriveToDestination} zeigt ein entsprechendes Aktivitätsdiagramm.

			%7.1.2.2    -driveAroundObstacle(destination: Destination): void
			\paragraph{Beschreibung der Methode \texttt{driveAroundObstacle}}
			\begin{figure}[H]
			\centering
			\includegraphics[width=0.95\textwidth]{img/1-Entwurf-7-driveAroundObstacle}
			\caption{Sequenzdiagramm zur Beschreibung der Methode \texttt{driveAroundObstacle}}
			\label{SequenzDriveAroundObstacle}
			\end{figure}

			Diese Methode wird von \texttt{driveToDestination} mit der Position eines \textit{Obstacles} aufgerufen, 
			wenn ein \textit{Obstacle} zu umfahren ist. 
			Im Spezialfall, dass es sich bei dem \textit{Obstacle} um einen anderen \textit{Robot} handelt, merken dies beide, wenn sie sich nähern und weichen beide nach rechts aus. 
			Im Allgemeinen entscheidet sich der \emph{Robot} zunächst, ob er links oder rechts an dem \textit{Obstacle} vorbeifährt, 
			und hält sich dann mithilfe seiner Sensoren immer auf einem bestimmten Abstand zum Hindernis, bis zwischen 
			\textit{Obstacle} und der Luftlinie zur \textit{Destination} genug Platz für den \textit{Robot} ist.
			
			Abbildung \ref{SequenzDriveAroundObstacle} zeigt ein entsprechendes Sequenzdiagramm. 
			Dabei ist \texttt{min\_dist} eine vorher festgelegte Konstante, welche die Mindestdistanz, die der \textit{Robot} halten muss, wenn er an einem \textit{Obstacle} vorbeifährt, speichert.
	
\pagebreak
	
%7.2 Paket Server
\subsection{Paket \textit{Server}}
%\begin{figure}[H]
%	\centering
%	\includegraphics[width=0.6\textwidth]{../images/Paketdetails.png}
%	\caption{\textcolor{blue}{HIER KOMMT DAS Server - PAKETDIAGRMAM HIN}}
%	\label{Paketdetails}
%	\end{figure}
	Im Folgenden werden die wichtigen Klassen des Pakets \textit{Server} 
	und ihre zugehörigen Methoden sowie ihre Interaktion untereinander beschrieben. 


	%7.2.1 TaskSystem
	\subsubsection{Beschreibung der Klasse \textit{TaskPriorityQueue}}
			\paragraph{Beschreibung der Methode \texttt{add}}		
			\paragraph{Beschreibung der Methode \texttt{addTopOfType}}		
			\paragraph{Beschreibung der Methode \texttt{poll}}		
			\paragraph{Beschreibung der Methode \texttt{remove}}		

	
			\paragraph{Beschreibung der Methode \texttt{assignTask}}
			Die Methode \texttt{assignTask} führt die Zuordnung und Abspeicherung der \emph{Robots} und \emph{Tasks} bzw. \emph{Destinations} durch. 
			Sie wird aufgerufen, wenn \texttt{chooseRobot} einen passenden \textit{Robot} gefunden hat, der einen \textit{Task} entgegennehmen kann. 
			Die Methode \texttt{assignTask} schickt dann eine neue \textit{Message} über den \textit{IWlanAdapter} an den \textit{Robot}, welche den \textit{Task} enthält.
			
	%7.2.2 RobotControlSystem
	\subsubsection{Beschreibung der Klasse \textit{VirtualRobotManager}}
			\paragraph{Beschreibung der Methode \texttt{handleArrival}}
			%7.2.1.1	~chooseRobot(destination: Destination): void
			\paragraph{Beschreibung der Methode \texttt{chooseRobot}}
			Die Methode \texttt{chooseRobot} wählt für den aktuell eingegangenen \emph{Task} einen \emph{Robot} aus. 
			Dazu fragt es die Sensorwerte der verschiedenen \emph{Robots} ab und wählt den am besten geeigneten aus.

			\paragraph{Beschreibung der Methode \texttt{notifyRepairService}}

	\subsubsection{Beschreibung der Klasse \textit{VirtualRobotUnit}}
	Die Klasse \textit{VirtualRobotUnit} ist die Umsetzung der Remote-Procedure-Calls von der Seite des \textit{Servers}. Diese Klasse implementiert die Methoden der von uns in 3. beschriebenen Interfaces \textit{ITask} und \textit{ISensorData}. Da diese Klasse auch die Repräsentation des \textit{Robots} auf dem \textit{Server} ist, werden hier auch Zustand des zugehörigen \textit{Robots}, insbesondere aktuell auszuführenden \textit{Task}, gespeichert. Alle Methoden dieser Klasse werden im \textit{Server} aufgerufen und Verfassen zunächst eine \textit{Message}, welche dann über die \textit{IWlanAdapter}-Schnittstelle verschickt werden und daraufhin die zugehörigen Lokalen Methoden auf den \textit{Robots} aufgerufen werden.
	
			\paragraph{Beschreibung der Methode \texttt{assignTask}}
			Mit dieser Methode teilt der \textit{Server} einem \textit{VirtualRobot} einen neuen \textit{Task} zu, der dann von dem zugehörigen \textit{Robot} ausgeführt wird. Auf dem zugehörigen \textit{Robot} wird dafür die Methode \texttt{setTask} aufgerufen.
			
			\paragraph{Beschreibung der Methode \texttt{continueTask}}
			Diese Methode wird zum Beispiel dann aufgerufen, wenn der \textit{Server} die Nachricht erhalten hat, dass sich der \textit{Customer} nun an Bord des \textit{Robots} befindet. Daraufhin wird eine \textit{Message} an den zu diesem \textit{VirtualRobot} zugehörigen \textit{Robot} geschickt, der ihn wissen lässt, dass er die nächste \textit{Destination} in seinem aktuellen \textit{Task}			
			
			\paragraph{Beschreibung der Methode \texttt{getSensorData}}
			