\section{Paketdetails}
\begin{figure}[H]
\centering
\includegraphics[height=0.75\linewidth, angle=90]{img/7-paketdetails}
\caption{Klassendiagramm zur detaillierten Beschreibung der strukturellen Gliederung}
\label{Paketdetails}
\end{figure}
%\pagebreak

%7.1 Paket Robot
\subsection{Paket \textit{RobotUnit}}
	Im Folgenden beschreiben wir die elementaren Klassen des Pakets \textit{RobotSoftware} 
	und ihre zugehörigen wichtigsten Methoden, sowie ihre Interaktion untereinander. 


	%7.1.1 RobotController
	\subsubsection{Beschreibung der Klasse \textit{RobotController}}
%		\begin{figure}[H]
%		\centering
%		\includegraphics[width=0.6\textwidth]{../images/Iteration0_Entwurf_7-1-1_Klasse_RobotController}
%		\caption{\textcolor{blue}{Durch eigene Diagramme ersetzen}}
%		\label{BeschreibungKlasse1}
%		\end{figure}
		
		%#destination : Destination
		Die Klasse \textit{RobotController} ist die Hauptklasse der \textit{RobotSoftware}, 
		da sie den aktuellen Zustand der \textit{RobotUnit} kapselt.
		Sie verwaltet alle internen Vorgänge der \emph{RobotUnit} und speichert den gerade verfolgten \textit{Task}. Dabei gibt es drei mögliche Zustände: 1. Die \emph{RobotUnit} verfolgt eine vom \emph{Server} auferlegte \emph{Task}. 2. Die \emph{RobotUnit} hat sich selbstständig den \emph{Task} gegeben, einen \emph{Charger} aufzusuchen. 3. Es gibt derzeit keinen \emph{Task}.

			%7.1.1.1 #collectSensorData():void
			\paragraph{Beschreibung der Methode \texttt{readSensors}}
			Der Server kann einen \textit{Robot} dazu auffordern, ihm seine Sensordaten zu schicken. 
			Der \textit{Robot} fragt dann seine Hardwareschnittstelle mittels der Methode \texttt{readSensors} 
			nach seiner Position und seinem Akkustand an und gibt diese Informationen zurück an den \textit{Server}. 
			Dazu wird natürlich zunächst eine \textit{Message} verfasst, welche dann über den \textit{IWlanAdapter} verschickt wird.
			
			\paragraph{Beschreibung der Methode \texttt{setTask}}
			Diese Methode wird aufgerufen, wenn der \textit{Robot} einen neuen Task erhält. Wenn der \textit{Robot} davor keinen \textit{Task} hatte, wird dieser einfach ausgeführt. Wenn der übergebene \textit{Task} \texttt{null} ist, nimmt der \textit{Robot} fahrt zur Ladestation auf. Wenn der \textit{Robot} gerade einen \textit{TaxiCustomer} an bord hat und in dieser Methode einen Krankenhaustransport als \textit{Task} erhält, wird der \textit{TaxiCustomer} abgeladen, und der Krankenhaustransport wird ausgeführt.
			
	\subsubsection{Beschreibung der Klasse \textit{VirtualServer}}
	Die Klasse \textit{VirtualServer} ist die Klasse, welche die Remote-Procedure-Calls von der Seite des \textit{Robots} implementiert. \textit{VirtualServer} implementiert unsere in 3. definierten Interfaces \textit{IRepair} und \textit{IArrivalNotification}. Alle Methoden in dieser Klasse verfassen natürlich eine \textit{Message} und nutzen dann die \textit{IWlanAdapter}-Schnittstelle, um diese an den \textit{Server} zu schicken.
	
			\paragraph{Beschreibung der Methode \texttt{informAboutArrival}}
			Diese Methode wird immer dann aufgerufen, wenn der \textit{Robot} die nächste \textit{Position} von seinem aktuellen \textit{Task} erreicht hat.  Da der \textit{Server} weiß, welcher \textit{Task} von welchem \textit{Robot} ausgeführt wird, muss \texttt{informAboutArrival} keine Parameter übergeben.
	
			\paragraph{Beschreibung der Methode \texttt{requestRepair}}
			Diese Methode wird dann von einen \textit{Robot} aufgerufen, wenn er nach einem Unfall kaputt ist. Der \textit{Robot} verfasst dafür eine \textit{Message} an den \textit{Server}, woraufhin auf dem \textit{Server} der \textit{Task}, den der kaputte \textit{Robot} gerade ausführen sollte, neu verteilt. In seiner Prioritätsstufe ist dieser \textit{Task} dann an erster Stelle, und wird nicht wieder hinten angestellt. Zusätzlich wird auf dem \textit{Server} dann die Methode \texttt{notifyRepairService} aufgerufen.		
			
	%7.1.2 DrivingSystem
	\subsubsection{Beschreibung der Klasse \textit{DrivingSystem}}
%		\begin{figure}[H]
%		\centering
%		\includegraphics[width=0.6\textwidth]{../images/Iteration0_Entwurf_7-1-2_Klasse_DrivingSystem}
%		\caption{\textcolor{blue}{Durch eigene Diagramme ersetzen}}
%		\label{BeschreibungKlasse1}
%		\end{figure}
		
		%#currentSpeed:float
		Diese Klasse beschreibt den aktuellen Zustand des Fahrsystems des \textit{Robots}. 
		Es sind Informationen über die aktuelle Geschwindigkeit enthalten und die Methode, 
		die gerade ausgeführt wird, gibt Auskunft über die aktuelle Beschäftigung des \textit{Robots}.

			%7.1.2.1 	#driveToDestination(destination: Destination, arrivalHandler: ArrivalHandler): void
			\paragraph{Beschreibung der Methode \texttt{driveToDestination}}
			\begin{figure}[H]
			\centering
			\includegraphics[width=1\textwidth]{img/7-1-methode_driveToDestination}
			\caption{Aktivitätsdiagramm zur Methode \texttt{driveToDestination}}
			\label{AktivitaetDriveToDestination}
			\end{figure}

			Wenn diese Methode aufgerufen wird, macht der \textit{Robot} sich auf den Weg zur 
			übergebenen \textit{Destination}. Wenn der \textit{Robot} an dieser \textit{Destination} 
			angekommen ist, wird die \texttt{arrive}-Methode des übergebenen \textit{ArrivalHandlers} ausgeführt. Wenn es sich bei der \textit{Destination} nicht um einen \textit{Charger} handelte, wird darin insbesondere über die von uns definierte Schnittstelle \textit{IArrivalNotifivation} der \textit{Server} über die Ankunft benachrichtigt. 
			Wenn sich ein \textit{Obstacle} auf dem Weg befindet, wird die Methode \texttt{driveAroundObstacle} 
			aufgerufen, bis das \textit{Obstacle} umfahren wurde.
			
			Abbildung \ref{AktivitaetDriveToDestination} zeigt ein entsprechendes Aktivitätsdiagramm.

			%7.1.2.2    -driveAroundObstacle(destination: Destination): void
			\paragraph{Beschreibung der Methode \texttt{driveAroundObstacle}}
			\begin{figure}[H]
			\centering
			\includegraphics[width=0.95\textwidth]{img/1-Entwurf-7-driveAroundObstacle}
			\caption{Sequenzdiagramm zur Beschreibung der Methode \texttt{driveAroundObstacle}}
			\label{SequenzDriveAroundObstacle}
			\end{figure}

			Diese Methode wird von \texttt{driveToDestination} mit der Position eines \textit{Obstacles} aufgerufen, 
			wenn ein \textit{Obstacle} zu umfahren ist. 
			Im Spezialfall, dass es sich bei dem \textit{Obstacle} um einen anderen \textit{Robot} handelt, merken dies beide, wenn sie sich nähern und weichen beide nach rechts aus. 
			Im Allgemeinen entscheidet sich der \emph{Robot} zunächst, ob er links oder rechts an dem \textit{Obstacle} vorbeifährt, 
			und hält sich dann mithilfe seiner Sensoren immer auf einem bestimmten Abstand zum Hindernis, bis zwischen 
			\textit{Obstacle} und der Luftlinie zur \textit{Destination} genug Platz für den \textit{Robot} ist.
			
			Abbildung \ref{SequenzDriveAroundObstacle} zeigt ein entsprechendes Sequenzdiagramm. 
			Dabei ist \texttt{min\_dist} eine vorher festgelegte Konstante, welche die Mindestdistanz, die der \textit{Robot} halten muss, wenn er an einem \textit{Obstacle} vorbeifährt, speichert.
	
\pagebreak
	
%7.2 Paket Server
\subsection{Paket \textit{Server}}
%\begin{figure}[H]
%	\centering
%	\includegraphics[width=0.6\textwidth]{../images/Paketdetails.png}
%	\caption{\textcolor{blue}{HIER KOMMT DAS Server - PAKETDIAGRMAM HIN}}
%	\label{Paketdetails}
%	\end{figure}
	Im Folgenden werden die wichtigen Klassen des Pakets \textit{Server} 
	und ihre zugehörigen Methoden sowie ihre Interaktion untereinander beschrieben. 


	%7.2.1 TaskSystem
	\subsubsection{Beschreibung der Klasse \textit{TaskQueue}}
	
	Diese Klasse ist für die Verwaltung von \textit{Tasks} auf dem \textit{Server} zuständig. Prinzipiell ist hier eine Queue implementiert, welche aber noch über zusätzliche Funktionen, wie z.B \texttt{addTop} und \texttt{remove} verfügt. Ziel dieser Datenstruktur ist es, die Wartezeiten für mögliche Taxikunden fair zu handhaben und die Verteilung an die \textit{Robots} vorzunehmen.
	
			\paragraph{Beschreibung der Methode \texttt{add}}		
			\begin{figure}[H]
			\centering
			\includegraphics[width=0.95\textwidth]{img/add}
			\caption{Sequenzdiagramm zur Beschreibung der Methode \texttt{add}}
			\label{SequenzQueueAdd}
			\end{figure}
			
			Die Methode \texttt{add} dient dazu neue Tasks in die Warteliste einzufügen.
			
			\paragraph{Beschreibung der Methode \texttt{addTop}}		
%			\begin{figure}[H]
%			\centering
%			\includegraphics[width=0.95\textwidth]{img/addTop}
%			\caption{Sequenzdiagramm zur Beschreibung der Methode \texttt{addTop}}
%			\label{SequenzQueueAddTop}
%			\end{figure}			
			
			Mit der Methode \texttt{addTop} können \textit{Tasks} in die Queue hinzugefügt werden, die davor schon aktiv von einem \textit{Robot} bearbeitet wurden, dann aber durch einen Defekt dessen neu verteilt werden müssen. 
			Die Besonderheit dieser \textit{Tasks} ist, dass sie an den Anfang der Queue hinzugefügt werden müssen.
				
			\paragraph{Beschreibung der Methode \texttt{poll}}		
			\begin{figure}[H]
			\centering
			\includegraphics[width=0.95\textwidth]{img/2-Entwurf-poll}
			\caption{Sequenzdiagramm zur Beschreibung der Methode \texttt{poll}}
			\label{SequenzQueuePoll}
			\end{figure}			
			
			Die Methode \texttt{poll} gibt den nächsten zu bearbeitenden Task zurück und entfernt diesen aus der Queue.
				
			\paragraph{Beschreibung der Methode \texttt{remove}}		
			\begin{figure}[H]
			\centering
			\includegraphics[width=0.95\textwidth]{img/2-Entwurf-remove}
			\caption{Sequenzdiagramm zur Beschreibung der Methode \texttt{remove}}
			\label{SequenzQueueRemove}
			\end{figure}			
			
			Die Methode \texttt{remove} entfernt einen spezifischen Task aus der Queue.
			
	%7.2.2 RobotControlSystem
	\subsubsection{Beschreibung der Klasse \textit{VirtualRobotManager}}
			\paragraph{Beschreibung der Methode \texttt{handleArrival}}
			\begin{figure}[H]
			\centering
			\includegraphics[width=0.95\textwidth]{img/HandleArrival}
			\caption{Sequenzdiagramm zur Beschreibung der Methode \texttt{handleArrival}}
			\label{SequenzQueuePoll}
			\end{figure}	
			Diese Methode wird immer dann aufgerufen, wenn der \textit{Server} eine \textit{Message} von einem \textit{Robot} erhält, welche von ihm über das von uns definierte Interface \textit{IArrivalNotification} gesandt wurde. Da der \textit{Server} eingespeichert hat, welchen \textit{Task} der \textit{Robot} gerade ausführt, müssen keine Parameter übergeben werden, sondern der \textit{Server} kann einfach nachschauen, welcher Typ von \textit{Destination} gerade erreicht wurde. Je nach Typ wird dann eine Benachrichtigung an die zugehörigen \textit{Customers} gesendet. Bei einem Taxiauftrag wird keine Nachricht an den Taxikunden geschickt, wenn dieser sein Ziel erreicht. Laut Aufgabenstellung ist eine Taxifahrt mit erreichen der \textit{Destination} des Taxikunden sofort beendet, ohne dass weitere Benachrichtigungen an den Taxikunden geschickt werden müssen.
			
			
			%7.2.1.1	~chooseRobot(destination: Destination): void
			\paragraph{Beschreibung der Methode \texttt{chooseRobot}}
			Die Methode \texttt{chooseRobot} wählt für den aktuell eingegangenen \emph{Task} einen \emph{Robot} aus. 
			Dazu fragt es die Sensorwerte der verschiedenen \emph{Robots} ab und wählt den am besten geeigneten aus.
				
			\begin{figure}[H]
			\centering
			\includegraphics[width=0.95\textwidth]{img/1-Analyse-3-Choose_Robot}
			\caption{Aktivitätsdiagramm zur Beschreibung der Methode \texttt{chooseRobot}}
			\label{SequenzQueueRemove}
			\end{figure}			
				
			\begin{figure}[H]
			\centering
			\includegraphics[width=0.95\textwidth]{img/2-Entwurf-SelectBestMatch}
			\caption{Aktivitätsdiagramm zur Beschreibung der Aktivität \texttt{selectBestMatch}}
			\label{SequenzQueueRemove}
			\end{figure}

			\paragraph{Beschreibung der Methode \texttt{notifyRepairService}}
			Wenn ein \textit{Robot} nach einem Zusammenstoß defekt ist, teilt er dies dem \textit{Server} unter Verwendung seiner Methode \texttt{requestRepair} mit.	Daraufhin erstellt der \textit{Server} einen neuen  \textit{Task}, der am Unfallort des \textit{Robots} beginnt. Der \textit{Customer}, der an Bord des verunglückten \textit{Robots} war, wird also nicht im Stich gelassen. Der neue \textit{Task} wird mit der Methode \texttt{addTopOfType} in die \textit{TaskPriorityQueue} eingefügt, um die Wartezeit dieses \textit{Customers} zu minimieren. Daraufhin benachrichtigt der \textit{Server} einen System-externen Servicedienst, und übergibt diesem die Position des Unfallorts. Nach unserer Annahme aus der Analyse wird der dort verunglückte \textit{Robot} dann nach einer endlichen Zeit wieder vom System benutzbar sein.
			
			
			
	\subsubsection{Beschreibung der Klasse \textit{VirtualRobotUnit}}
	Die Klasse \textit{VirtualRobotUnit} ist die Umsetzung der Remote-Procedure-Calls von der Seite des \textit{Servers}. Diese Klasse implementiert die Methoden der von uns in 3. beschriebenen Interfaces \textit{ITask} und \textit{ISensorData}. Da diese Klasse auch die Repräsentation des \textit{Robots} auf dem \textit{Server} ist, werden hier auch Zustand des zugehörigen \textit{Robots}, insbesondere aktuell auszuführenden \textit{Task}, gespeichert. Alle Methoden dieser Klasse werden im \textit{Server} aufgerufen und Verfassen zunächst eine \textit{Message}, welche dann über die \textit{IWlanAdapter}-Schnittstelle verschickt werden und daraufhin die zugehörigen Lokalen Methoden auf den \textit{Robots} aufgerufen werden.
	
			\paragraph{Beschreibung der Methode \texttt{assignTask}}
			Mit dieser Methode teilt der \textit{Server} einem \textit{VirtualRobot} einen neuen \textit{Task} zu, der dann von dem zugehörigen \textit{Robot} ausgeführt wird. Auf dem zugehörigen \textit{Robot} wird dafür die Methode \texttt{setTask} aufgerufen.
			
			\paragraph{Beschreibung der Methode \texttt{continueTask}}
			Diese Methode wird zum Beispiel dann aufgerufen, wenn der \textit{Server} die Nachricht erhalten hat, dass sich der \textit{Customer} nun an Bord des \textit{Robots} befindet. Daraufhin wird eine \textit{Message} an den zu diesem \textit{VirtualRobot} zugehörigen \textit{Robot} geschickt, der ihn wissen lässt, dass er die nächste \textit{Destination} in seinem aktuellen \textit{Task}			
			
			\paragraph{Beschreibung der Methode \texttt{getSensorData}}
			Der \textit{Server} möchte im Rahmen von \texttt{Choose Robot} Informationen über den Akkustand und die Position von allen \textit{Robots} erhalten. Dazu wird auf jedem \textit{VirtualRobot} diese Methode aufgerufen, bei der über die \textit{IWlanAdapter}-Schnittstelle eine entsprechende \textit{Message} an den jeweils zugehörigen \textit{Robot} geschickt wird. Diese \textit{Robots} rufen dann die Methode \texttt{readSensors} auf.
